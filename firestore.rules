rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * Core Philosophy: This ruleset enforces a strict role-based and ownership-based security model
     * designed for an educational application. The core principle is "default deny," where access
     * is only granted through explicit rules.
     *
     * Data Structure:
     * - User-centric data (profiles, assessments) is nested under /users/{userId} to leverage
     *   path-based ownership security.
     * - Academic content (assignments, projects, exams) is nested under /batches/{batchId},
     *   creating a clear scope for access control.
     * - Shared, top-level collections (/batches, /subjects) are used for common institutional data.
     * - A dedicated /roles_admin collection handles global administrator privileges.
     *
     * Key Security Decisions:
     * - Strict User Ownership: Users can only access and manage their own documents within the
     *   /users/{userId} data tree. Listing other users' data is forbidden.
     * - Role-Based Access: A user's capabilities are determined by their role (student or teacher)
     *   and the scope defined in their profile (e.g., a teacher's assigned batchIds).
     * - Authorization Independence: Documents contain the necessary fields (e.g., creator IDs,
     *   batch IDs) to make authorization decisions without costly lookups on other documents,
     *   with the explicit exception of checking the authenticated user's own profile to establish
     *   their permissions.
     * - Global Admins: A user with a document in /roles_admin/{userId} is granted global
     *   administrative privileges for managing core data like batches and subjects.
     */

    // ----------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * Checks for ownership and that the document already exists.
     * CRITICAL for preventing modifications to non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Checks if the authenticated user has a global administrator role.
     * This is determined by the existence of their UID in the /roles_admin collection.
     */
    function isAdmin() {
      return exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Retrieves the authenticated user's student profile document.
     * Assumes a 1:1 model where the doc ID in the subcollection is the user's UID.
     */
    function userStudentProfile() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)/studentProfile/$(request.auth.uid));
    }

    /**
     * Retrieves the authenticated user's teacher profile document.
     * Assumes a 1:1 model where the doc ID in the subcollection is the user's UID.
     */
    function userTeacherProfile() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)/teacherProfile/$(request.auth.uid));
    }

    /**
     * Checks if the authenticated user is a student belonging to a specific batch.
     * Performs a targeted 'get' on the user's own profile to determine their scope.
     */
    function isStudentInBatch(batchId) {
      let profile = userStudentProfile();
      return profile != null && profile.data.batchId == batchId;
    }

    /**
     * Checks if the authenticated user is a teacher assigned to a specific batch.
     * Performs a targeted 'get' on the user's own profile to determine their scope.
     */
    function isTeacherForBatch(batchId) {
      let profile = userTeacherProfile();
      return profile != null && batchId in profile.data.batchIds;
    }

    /**
     * Checks if the authenticated user is a teacher assigned to a specific subject.
     * Performs a targeted 'get' on the user's own profile to determine their scope.
     */
    function isTeacherForSubject(subjectId) {
      let profile = userTeacherProfile();
      return profile != null && subjectId in profile.data.subjectIds;
    }


    /**
     * @description Rules for the admin roles collection. Only existing admins can read or manage this list.
     * @path /roles_admin/{adminId}
     * @allow An existing admin (auth.uid exists in /roles_admin) (create) their own or another user's admin role document.
     * @deny A non-admin user (get) attempting to read the list of admins.
     * @principle Restricts management of highly privileged roles to other holders of that role, preventing privilege escalation.
     */
    match /roles_admin/{adminId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Rules for a user's primary document. Users can create their own document and can read/update it, but not delete it.
     * @path /users/{userId}
     * @allow A new user (auth.uid: 'user_abc') (create) their own document at /users/user_abc.
     * @deny A logged-in user (auth.uid: 'user_xyz') (get) attempting to read /users/user_abc.
     * @principle Enforces Self-Creation and strict document ownership for a user's root document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if false;
    }

    /**
     * @description Rules for a user's student profile. Only the owning user can manage their profile.
     * @path /users/{userId}/studentProfile/{profileId}
     * @allow The user 'user_abc' (create) their student profile at /users/user_abc/studentProfile/user_abc.
     * @deny The user 'user_xyz' (update) the profile at /users/user_abc/studentProfile/user_abc.
     * @principle Restricts access to a user's own data tree and enforces a 1-to-1 relationship by matching the document ID to the user ID.
     */
    match /users/{userId}/studentProfile/{profileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && profileId == userId && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && profileId == userId && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId) && profileId == userId;
    }

    /**
     * @description Rules for a user's teacher profile. Only the owning user can manage their profile.
     * @path /users/{userId}/teacherProfile/{profileId}
     * @allow The user 'user_abc' (create) their teacher profile at /users/user_abc/teacherProfile/user_abc.
     * @deny The user 'user_xyz' (get) the profile at /users/user_abc/teacherProfile/user_abc.
     * @principle Restricts access to a user's own data tree and enforces a 1-to-1 relationship by matching the document ID to the user ID.
     */
    match /users/{userId}/teacherProfile/{profileId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && profileId == userId && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && profileId == userId && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId) && profileId == userId;
    }

    /**
     * @description Rules for a student's internal assessment records. The student can read their own assessments. The assessing teacher can create and manage them.
     * @path /users/{studentId}/internalAssessments/{assessmentId}
     * @allow The student 'student_abc' (get) their own assessment at /users/student_abc/internalAssessments/asm_123.
     * @deny A different student 'student_xyz' (get) the assessment at /users/student_abc/internalAssessments/asm_123.
     * @principle Enforces a shared access model where data is owned by one user but writable by another authorized user (teacher).
     */
    match /users/{studentId}/internalAssessments/{assessmentId} {
      allow get: if isOwner(studentId) || isOwner(resource.data.assessedByTeacherId);
      allow list: if isOwner(studentId);
      allow create: if isTeacherForSubject(request.resource.data.subjectId) && request.resource.data.assessedByTeacherId == request.auth.uid && request.resource.data.studentId == studentId;
      allow update: if (isOwner(resource.data.assessedByTeacherId) || isAdmin()) && resource != null;
      allow delete: if (isOwner(resource.data.assessedByTeacherId) || isAdmin()) && resource != null;
    }

    /**
     * @description Rules for academic batches. Any signed-in user can view batches, but only admins can manage them.
     * @path /batches/{batchId}
     * @allow Any authenticated user (get) to read a batch document.
     * @deny A teacher who is not an admin (create) attempting to create a new batch.
     * @principle Provides public read access for core institutional data while restricting modifications to privileged admin roles.
     */
    match /batches/{batchId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      // CRITICAL: Cannot implement teacher-manager writes. The 'Batch' entity is missing a 'managerTeacherIds' field.
      allow create: if isAdmin(); // TODO: Add teacher validation once the schema is updated with a 'managerTeacherIds' field.
      allow update: if isAdmin() && resource != null; // TODO: Add teacher validation once the schema is updated.
      allow delete: if isAdmin() && resource != null; // TODO: Add teacher validation once the schema is updated.
    }

    /**
     * @description Rules for academic subjects. Any signed-in user can view subjects, but only admins can manage them.
     * @path /subjects/{subjectId}
     * @allow Any authenticated user (get) to read a subject document.
     * @deny A teacher who is not an admin (update) attempting to modify a subject.
     * @principle Provides public read access for core institutional data while restricting modifications to privileged admin roles.
     */
    match /subjects/{subjectId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      // CRITICAL: Cannot implement teacher writes. The 'Subject' entity is missing a 'teachingTeacherIds' field.
      allow create: if isAdmin(); // TODO: Add teacher validation once the schema is updated with a 'teachingTeacherIds' field.
      allow update: if isAdmin() && resource != null; // TODO: Add teacher validation once the schema is updated.
      allow delete: if isAdmin() && resource != null; // TODO: Add teacher validation once the schema is updated.
    }

    /**
     * @description Rules for assignments within a batch. Students in the batch can read. Teachers for the batch can create and manage.
     * @path /batches/{batchId}/assignments/{assignmentId}
     * @allow A student in 'batch_a' (get) an assignment at /batches/batch_a/assignments/asm_123.
     * @deny A student in 'batch_b' (get) the assignment at /batches/batch_a/assignments/asm_123.
     * @principle Enforces hierarchical access control where permissions are derived from the parent collection's scope (the batch).
     */
    match /batches/{batchId}/assignments/{assignmentId} {
      allow get: if isStudentInBatch(batchId) || isTeacherForBatch(batchId) || isAdmin();
      allow list: if isStudentInBatch(batchId) || isTeacherForBatch(batchId) || isAdmin();
      allow create: if (isTeacherForBatch(batchId) || isAdmin()) && request.resource.data.batchId == batchId && request.resource.data.assignedByTeacherId == request.auth.uid;
      allow update: if (isOwner(resource.data.assignedByTeacherId) || isAdmin()) && resource != null && request.resource.data.batchId == resource.data.batchId;
      allow delete: if (isOwner(resource.data.assignedByTeacherId) || isAdmin()) && resource != null;
    }

    /**
     * @description Rules for projects within a batch. Students in the batch can read. Teachers for the batch can create and manage.
     * @path /batches/{batchId}/projects/{projectId}
     * @allow A teacher for 'batch_a' (create) a project at /batches/batch_a/projects/proj_456.
     * @deny A teacher for 'batch_b' (create) a project at /batches/batch_a/projects/proj_456.
     * @principle Enforces hierarchical access control where permissions are derived from the parent collection's scope (the batch).
     */
    match /batches/{batchId}/projects/{projectId} {
      allow get: if isStudentInBatch(batchId) || isTeacherForBatch(batchId) || isAdmin();
      allow list: if isStudentInBatch(batchId) || isTeacherForBatch(batchId) || isAdmin();
      allow create: if (isTeacherForBatch(batchId) || isAdmin()) && request.resource.data.batchId == batchId && request.resource.data.assignedByTeacherId == request.auth.uid;
      allow update: if (isOwner(resource.data.assignedByTeacherId) || isAdmin()) && resource != null && request.resource.data.batchId == resource.data.batchId;
      allow delete: if (isOwner(resource.data.assignedByTeacherId) || isAdmin()) && resource != null;
    }

    /**
     * @description Rules for exams within a batch. Students in the batch can read. Teachers for the batch can create and manage.
     * @path /batches/{batchId}/exams/{examId}
     * @allow An admin (get) an exam at /batches/batch_a/exams/exam_789.
     * @deny A student not in 'batch_a' (list) exams at /batches/batch_a/exams.
     * @principle Enforces hierarchical access control where permissions are derived from the parent collection's scope (the batch).
     */
    match /batches/{batchId}/exams/{examId} {
      allow get: if isStudentInBatch(batchId) || isTeacherForBatch(batchId) || isAdmin();
      allow list: if isStudentInBatch(batchId) || isTeacherForBatch(batchId) || isAdmin();
      allow create: if (isTeacherForBatch(batchId) || isAdmin()) && request.resource.data.batchId == batchId && request.resource.data.assignedByTeacherId == request.auth.uid;
      allow update: if (isOwner(resource.data.assignedByTeacherId) || isAdmin()) && resource != null && request.resource.data.batchId == resource.data.batchId;
      allow delete: if (isOwner(resource.data.assignedByTeacherId) || isAdmin()) && resource != null;
    }

  }
}