/**
 * Core Philosophy:
 * This ruleset enforces a role-based security model for an educational application with two primary user types: Students and Teachers.
 * A user's role and their associated context (e.g., which batches or subjects they belong to) are stored directly on their own user profile document.
 * Authorization decisions are made by looking up this context, ensuring that a user can only access data relevant to them.
 *
 * Data Structure:
 * The data is organized into top-level collections for each primary entity (`students`, `teachers`, `batches`, `subjects`, `assessments`, `submissions`).
 * This flat structure simplifies rule writing and avoids complex path-based security logic.
 *
 * Key Security Decisions:
 * - User Profiles Are Private: A user can only access their own document in `/students` or `/teachers`. User listing is disabled to prevent enumeration.
 * - Authorization Independence via Denormalization: To ensure rules are fast and secure, authorization context is denormalized. For example, a student's `batchId` is on their profile, and a teacher's `batchIds` are on theirs. `Submission` documents are expected to contain denormalized IDs from their parent `Assessment` (e.g., `assessmentBatchId`) to avoid costly and complex `get()` calls in rules.
 * - Admin-Only Writes Default to `false`: Core academic data like `batches` and `subjects` can be read by any authenticated user but cannot be modified, as an admin role is not defined. This enforces a "secure by default" posture.
 * - Granular Access for Assessments & Submissions:
 *   - Students can only see assessments for their specific batch.
 *   - Teachers can create assessments and can see submissions related to the batches they teach.
 *   - Students can create and update their own submissions (if not yet graded) but cannot delete them or view others' submissions.
 *
 * Denormalization for Authorization:
 * - Student Profile: `/students/{studentId}` must contain `batchId`.
 * - Teacher Profile: `/teachers/{teacherId}` must contain a `batchIds` array.
 * - Assessment Document: `/assessments/{assessmentId}` must contain `batchId` and `teacherId`.
 * - Submission Document: `/submissions/{submissionId}` must contain `studentId` and a denormalized `assessmentBatchId` to allow teachers to access submissions without extra reads.
 *
 * Structural Segregation:
 * The use of separate top-level collections (e.g., `/students`, `/teachers`) provides strong security boundaries and prevents accidental data leakage between user roles.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------
    // Helper Functions
    // --------------------------------

    /**
     * Verifies that a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Verifies that the requesting user's UID matches the provided userId.
     * This is the foundation for document ownership.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    /**
     * Verifies that a document already exists.
     * CRITICAL for all update and delete operations to prevent unintended behavior.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Checks if the requesting user has a profile in the /students collection.
     */
    function isStudent() {
      return isSignedIn() && exists(/databases/$(database)/documents/students/$(request.auth.uid));
    }

    /**
     * Checks if the requesting user has a profile in the /teachers collection.
     */
    function isTeacher() {
      return isSignedIn() && exists(/databases/$(database)/documents/teachers/$(request.auth.uid));
    }

    /**
     * Retrieves the authenticated user's student profile data.
     * This lookup is essential for getting the student's authorization context (e.g., their batchId).
     */
    function getStudentData() {
      return get(/databases/$(database)/documents/students/$(request.auth.uid)).data;
    }

    /**
     * Retrieves the authenticated user's teacher profile data.
     * This lookup is essential for getting the teacher's authorization context (e.g., their list of batchIds).
     */
    function getTeacherData() {
      return get(/databases/$(database)/documents/teachers/$(request.auth.uid)).data;
    }
    
    /**
     * Checks if the current user is a student belonging to a specific batch.
     */
    function isStudentInBatch(batchId) {
      return isStudent() && getStudentData().batchId == batchId;
    }

    /**
     * Checks if the current user is a teacher assigned to a specific batch.
     */
    function isTeacherForBatch(batchId) {
      return isTeacher() && batchId in getTeacherData().batchIds;
    }

    // --------------------------------
    // User Profile Collections
    // --------------------------------

    /**
     * @description Controls access to student user profiles. Only the owner of the profile can access or modify it.
     * @path /students/{studentId}
     * @allow (create) A new student creating their own profile: `auth.uid == studentId`.
     * @deny (get) Another student trying to read this profile: `auth.uid != studentId`.
     * @principle Restricts access to a user's own data tree, preventing data leakage and user enumeration.
     */
    match /students/{studentId} {
      allow get: if isOwner(studentId);
      allow list: if false;
      allow create: if isOwner(studentId) && request.resource.data.id == studentId;
      allow update: if isOwner(studentId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(studentId) && isExistingDoc();
    }

    /**
     * @description Controls access to teacher user profiles. Only the owner of the profile can access or modify it.
     * @path /teachers/{teacherId}
     * @allow (update) A teacher updating their own profile details: `auth.uid == teacherId`.
     * @deny (list) Any user trying to get a list of all teachers.
     * @principle Restricts access to a user's own data tree, preventing data leakage and user enumeration.
     */
    match /teachers/{teacherId} {
      allow get: if isOwner(teacherId);
      allow list: if false;
      allow create: if isOwner(teacherId) && request.resource.data.id == teacherId;
      allow update: if isOwner(teacherId) && isExistingDoc() && request.resource.data.id == resource.data.id;
      allow delete: if isOwner(teacherId) && isExistingDoc();
    }
    
    // --------------------------------
    // Core Academic Data Collections
    // --------------------------------

    /**
     * @description Controls access to academic batches. This data is considered public read for any authenticated user.
     * @path /batches/{batchId}
     * @allow (get) Any authenticated student or teacher reading batch details.
     * @deny (create) Any user trying to create a new batch. This requires admin privileges not defined here.
     * @principle Provides public read access for foundational data while securing it against unauthorized modification.
     */
    match /batches/{batchId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to academic subjects. This data is considered public read for any authenticated user.
     * @path /subjects/{subjectId}
     * @allow (list) Any authenticated student or teacher listing available subjects.
     * @deny (update) Any user trying to change a subject's details. This requires admin privileges not defined here.
     * @principle Provides public read access for foundational data while securing it against unauthorized modification.
     */
    match /subjects/{subjectId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    // --------------------------------
    // Transactional Collections
    // --------------------------------

    /**
     * @description Controls access to assessments. Teachers can create/manage them. Students can only read assessments relevant to their batch.
     * @path /assessments/{assessmentId}
     * @allow (get) A student reading an assessment for their batch: `isStudentInBatch(resource.data.batchId)`.
     * @deny (update) A student trying to modify an assessment's deadline.
     * @principle Enforces role-based access control where permissions depend on the user's role (Student/Teacher) and context (their assigned batch).
     */
    match /assessments/{assessmentId} {
      allow get: if (isStudent() && isStudentInBatch(resource.data.batchId)) || isTeacher();
      allow list: if isSignedIn();
      allow create: if isTeacher() && isOwner(request.resource.data.teacherId);
      allow update: if isTeacher() && isExistingDoc() && isOwner(resource.data.teacherId);
      allow delete: if isTeacher() && isExistingDoc() && isOwner(resource.data.teacherId);
    }
    
    /**
     * @description Controls access to student submissions. Students can manage their own submissions, and authorized teachers can review and grade them.
     * @path /submissions/{submissionId}
     * @allow (create) A student submitting work for an assessment: `isOwner(request.resource.data.studentId)`.
     * @allow (update) A teacher grading a submission for a batch they teach: `isTeacherForBatch(resource.data.assessmentBatchId)`.
     * @deny (get) A student trying to read another student's submission.
     * @deny (delete) Any user trying to delete a submission record.
     * @principle Enforces document ownership for students and contextual access for teachers based on denormalized data (`assessmentBatchId`).
     */
    match /submissions/{submissionId} {
      allow get: if isExistingDoc() && (isOwner(resource.data.studentId) || isTeacherForBatch(resource.data.assessmentBatchId));
      allow list: if isSignedIn();
      allow create: if isStudent() && isOwner(request.resource.data.studentId);
      allow update: if isExistingDoc() && ((isOwner(resource.data.studentId) && resource.data.grade == null) || isTeacherForBatch(resource.data.assessmentBatchId));
      allow delete: if false;
    }
  }
}